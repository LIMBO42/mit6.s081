### Isolation：

<img src="https://typora-1306385380.cos.ap-nanjing.myqcloud.com/img/image-20220426103825629.png" alt="image-20220426103825629" style="zoom:67%;" />

如果缺少isolation，那么应用程序需要自己完成调度，自己释放cpu资源，如果直接接触到物理内存，两个进程之间会发生冲突，比如说会覆盖。

使用操作系统的一个原因，甚至可以说是主要原因就是为了实现multiplexing和内存隔离。

**操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，进程抽象了CPU**，这样操作系统才能在多个应用程序之间复用一个或者多个CPU。

**exec抽象了内存。当我们在执行exec系统调用的时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的内存镜像。**（可执行文件实际上对应了内存镜像）。内存镜像里面包括了程序对应的指令，全局的数据。应用程序可以逐渐扩展自己的内存，但是应用程序并没有直接访问物理内存的权限，例如应用程序不能直接访问物理内存的1000-2000这段地址。不能直接访问的原因是，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。

**Files基本上来说抽象了磁盘。**应用程序不会直接读写挂在计算机上的磁盘本身，并且在Unix中这也是不被允许的。在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。



### 硬件对于强隔离的支持

user mode; kernel mode

#### 1.用户态和内核态的隔离

在内核态可以运行特权指令（一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。）

question：如何切换到内核态？

通过特殊的特权指令即可，将cpu中的flag置1。

通过系统调用，触发软终端，查询中断向量表，执行中断处理程序，而中断处理程序在内核中，这样就能陷入内核。

#### 2.内存之间的隔离

通过page table 来实现，每个进程有自己独立的page table，映射到的物理内存空间不重合，这样实现了不同进程内存之间的隔离。



RSIC-V 通过ecall完成用户态内核态的切换



#### 3.宏内核VS微内核

##### 宏内核：

所有OS的代码均运行在内核，优点是各个模块可以紧密结合，共享，性能好；缺点是bug产生在内核会很危险

##### 微内核：

内核只有必要的代码（IPC：进程间通信），缺点是性能低，用户态内核态的切换频繁，实现某个功能需要IPC发送信息，接受信息。





#### 4.kernel的编译：

![img](https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHZoT2b_bcLghjAOPsJ%2F-MJdmgC_aByY8_wjKNKA%2F-MJgXiV2KBGQeuPgX4Bj%2Fimage.png?alt=media&token=80f80f91-adbc-48c7-9767-e6db633cb141)

将.c文件编译成汇编，然后成.o，然后链接成可执行文件



#### 5.qemu

qemu是C语言的程序，用来模拟RISC-V指令集的行为：

qemu执行循环：读指令，解析指令，执行指令

![image-20220426142129492](https://typora-1306385380.cos.ap-nanjing.myqcloud.com/img/image-20220426142129492.png)



