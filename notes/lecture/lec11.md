线程的状态包含了三个部分：

- 程序计数器（Program Counter），它表示当前线程执行指令的位置。
- 保存变量的寄存器。
- 程序的Stack。通常来说每个线程都有属于自己的Stack，Stack记录了函数调用的记录，并反映了当前线程的执行点。

不同线程系统之间的一个主要的区别就是，线程之间是否会共享内存。一种可能是你有一个地址空间，多个线程都在这一个地址空间内运行，并且它们可以看到彼此的更新。比如说共享一个地址空间的线程修改了一个变量，共享地址空间的另一个线程可以看到变量的修改。所以当多个线程运行在一个共享地址空间时，我们需要用到锁。

<img src="https://typora-1306385380.cos.ap-nanjing.myqcloud.com/img/image-20220510092640032.png" alt="image-20220510092640032" style="zoom:50%;" />

利用定时器中断。在每个CPU核上，都存在一个硬件设备，它会定时产生中断。可以打断某些一直占用cpu的用户进程，从而不会出现某个进程一直占用的情况。

中断来临之后，定时中断处理程序运行，而定时器中断处理程序，会自愿的将CPU出让（yield）给线程调度器。

如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的用户空间状态会被保存在程序的trapframe中，同时属于这个用户程序的内核线程被激活。所以首先，用户的程序计数器，寄存器等等被保存到了trapframe中，之后CPU被切换到内核栈上运行，实际上会走到trampoline和usertrap代码中，之后内核会运行一段时间处理系统调用或者执行中断处理程序。在处理完成之后，选择合适的进程/线程运行。



1.从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存用户进程的状态并运行第一个用户进程的内核线程。

2.再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。

3.之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。

4.最后返回到第二个用户进程继续执行。